const yaml = require('yaml')
const { readFileSync, writeFileSync } = require('fs')

const filenameBase = 'parser'
const filenameCpp = `${filenameBase}.cpp`
const filenameH = `${filenameBase}.h`

const commands = yaml.parse(readFileSync('commands.yml').toString())

const className = snake => snake.split('_').map(x => x.slice(0, 1).toUpperCase() + x.slice(1)).join('')
String.prototype.indent = function (level) {
  return this.split('\n').map(line => (' '.repeat(level * 2) + line).trimEnd()).join('\n')
}

const stdtype = str => str === 'string' ? 'std::string' : str
const type = (arg, std = stdtype(arg.type)) => arg.array
  ? `Vector<${std}>`
  : arg.optional
    ? `Optional<${std}>`
    : std
const getValue = (type, varname) => {
  if (type === 'int') return `atoi(${varname})`
  if (type === 'char') return `*${varname}`
  if (type === 'SortType') return `${varname}[0] == 't' ? kTime : kCost`
  if (type === 'Duration') return `Duration(atoi(${varname}))`
  if ([ 'Date', 'Instant' ].includes(type)) return `${type}(${varname})`
  return varname
}

const ARG_RE = /^(?<type>[^ ]+) (?<name>[a-zA-Z0-9]+)(?<optional>\?)?(?<array>\[\])?(?<default> = .+)?$/
const parseArg = str => str.match(ARG_RE).groups
const declareArg = ([ _, value ]) => {
  const parsed = parseArg(value)
  return `${type(parsed)} ${parsed.name}${parsed.default ?? ''};`
}
const getArray = (name, parsed, varname) => {
  if (parsed.type === 'string') return `std::string val = ${varname};
  res.${name} = copyStrings(split(val, '|'));`
  return `std::string val = ${varname};
  auto values = split(val, '|');
  res.${name}.reserve(values.size());
  for (auto &str : values) {
    res.${name}.push_back(${getValue(parsed.type, 'str.data()')});
  }`
}
const testArg = ([ name, value ]) => {
  const parsed = parseArg(value)
  return `
if (arg == "${name}") {
  ${parsed.array
    ? getArray(parsed.name, parsed, 'argv[++i].data()')
    : `res.${parsed.name} = ${getValue(parsed.type, 'argv[++i].data()')};`}
} else
`.slice(1, -1)
}
const header = ([ name, args ]) => `
struct ${className(name)} {
  ${Object.entries(args).map(declareArg).join('\n  ')}
};
`.slice(1)

const implementation = ([ name, args ]) => `
if (argv0 == "${name}") {
${Object.keys(args).length == 0 ? `
  return Command(${className(name)}());`.slice(1) : `
  ${className(name)} res;
  for (int i = 1; i < argv.size(); ++i) {
    auto &arg = argv[i];
${Object.entries(args).map(testArg).join(' ').indent(2)} {
      return ParseException();
    }
  }
  return Command(res);
`.slice(1, -1)}
} else
`.trim()

const dispatchOverload = name => `auto dispatch (const ${name} &cmd) -> void;`

const defineGuard = 'TICKET_PARSER_H_'
const ns = `ticket::command`
const h = `
// This file is autogenerated. Do not modify.
#ifndef ${defineGuard}
#define ${defineGuard}

#include <iostream>

#include "datetime.h"
#include "exception.h"
#include "optional.h"
#include "variant.h"
#include "result.h"

/// Classes and parsers for commands.
namespace ${ns} {

enum SortType { kTime, kCost };

${Object.entries(commands).map(header).join('\n')}

using Command = Variant<
  ${Object.keys(commands).map(className).join(',\n  ')}
>;

/**
 * @brief parses the command stored in str.
 *
 * this function is autogenerated.
 */
auto parse (std::string &str)
  -> Result<Command, ParseException>;

/**
 * @brief Visitor for the commands.
 *
 * The main function uses this visitor after parsing a
 * command, to actually dispatch it. Overloads of operator()
 * are callbacks of the commands.
 *
 * The implementations are in the corresponding source
 * files, not in ${filenameCpp}.
 */
${Object.keys(commands).map(className).map(dispatchOverload).join('\n')}

} // namespace ${ns}

#endif // ${defineGuard}
`.slice(1)

const cpp = `
// This file is autogenerated. Do not modify.
#include "${filenameH}"

#include "utility.h"

namespace ${ns} {

auto parse (std::string &str)
  -> Result<Command, ParseException> {
  auto argv = split(str, ' ');
  auto &argv0 = argv[0];
${Object.entries(commands).map(implementation).join(' ').indent(1)} {
    return ParseException();
  }
}

} // namespace ${ns}
`.slice(1)

const dir = 'src/'
writeFileSync(dir + filenameH, h)
writeFileSync(dir + filenameCpp, cpp)
